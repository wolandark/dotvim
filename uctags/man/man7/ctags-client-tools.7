.\" Man page generated from reStructuredText.
.
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.TH "CTAGS-CLIENT-TOOLS" "7" "" "6.1.0" "Universal Ctags"
.SH NAME
ctags-client-tools \- Hints for developing a tool using ctags command and tags output
.SH SYNOPSIS
.nf
\fBctags\fP [options] [file(s)]
\fBetags\fP [options] [file(s)]
.fi
.sp
.SH DESCRIPTION
.sp
\fBClient tool\fP means a tool running the ctags command
and/or reading a tags file generated by ctags command.
This man page gathers hints for people who develop client tools.
.SH PSEUDO-TAGS
.sp
\fBPseudo\-tags\fP, stored in a tag file, indicate how
ctags generated the tags file: whether the
tags file is sorted or not, which version of tags file format is used,
the name of tags generator, and so on. The opposite term for
pseudo\-tags is \fBregular\-tags\fP\&. A regular\-tag is for a language
object in an input file. A pseudo\-tag is for the tags file
itself. Client tools may use pseudo\-tags as reference for processing
regular\-tags.
.sp
A pseudo\-tag is stored in a tags file in the same format as
regular\-tags as described in tags(5), except that pseudo\-tag names
are prefixed with \(dq!_\(dq. For the general information about
pseudo\-tags, see \(dqTAG FILE INFORMATION\(dq in tags(5).
.sp
An example of a pseudo tag:
.INDENT 0.0
.INDENT 3.5
.sp
.EX
!_TAG_PROGRAM_NAME      Universal Ctags /Derived from Exuberant Ctags/
.EE
.UNINDENT
.UNINDENT
.sp
The value, \(dqUniversal Ctags\(dq, associated with the pseudo tag \fBTAG_PROGRAM_NAME\fP, is
used in the field for input file. The description, \(dqDerived from
Exuberant Ctags\(dq, is used in the field for pattern.
.sp
Universal Ctags extends the naming scheme of the classical pseudo\-tags
available in Exuberant Ctags for emitting language specific
information as pseudo tags:
.INDENT 0.0
.INDENT 3.5
.sp
.EX
!_{pseudo\-tag\-name}!{language\-name}     {associated\-value}      /{description}/
.EE
.UNINDENT
.UNINDENT
.sp
The language\-name is appended to the pseudo\-tag name with a separator, \(dq!\(dq.
.sp
An example of pseudo tag with a language suffix:
.INDENT 0.0
.INDENT 3.5
.sp
.EX
!_TAG_KIND_DESCRIPTION!C        f,function      /function definitions/
.EE
.UNINDENT
.UNINDENT
.sp
This pseudo\-tag says \(dqthe function kind of C language is enabled
when generating this tags file.\(dq \fB\-\-pseudo\-tags\fP is the option for
enabling/disabling individual pseudo\-tags. When enabling/disabling a
pseudo tag with the option, specify the tag name only
\fBTAG_KIND_DESCRIPTION\fP, without the prefix (\(dq!_\(dq) or the suffix (\(dq!C\(dq).
.SS Options for Pseudo\-tags
.INDENT 0.0
.TP
.B \fB\-\-extras=+p\fP (or \fB\-\-extras=+{pseudo}\fP)
Forces writing pseudo\-tags.
.sp
ctags emits pseudo\-tags by default when writing tags
to a regular file (e.g. \(dqtags\(aq.) However, when specifying \fB\-o \-\fP
or \fB\-f \-\fP for writing tags to standard output,
ctags doesn\(aqt emit pseudo\-tags. \fB\-\-extras=+p\fP or
\fB\-\-extras=+{pseudo}\fP will force pseudo\-tags to be written.
.TP
.B \fB\-\-list\-pseudo\-tags\fP
Lists available types of pseudo\-tags and shows whether they are enabled or disabled.
.sp
Running ctags with \fB\-\-list\-pseudo\-tags\fP option
lists available pseudo\-tags. Some of pseudo\-tags newly introduced
in Universal Ctags project are disabled by default. Use
\fB\-\-pseudo\-tags=...\fP to enable them.
.TP
.B \fB\-\-pseudo\-tags=[+|\-]names|*\fP
Specifies a list of pseudo\-tag types to include in the output.
.sp
The parameters are a set of pseudo tag names. Valid pseudo tag names
can be listed with \fB\-\-list\-pseudo\-tags\fP\&. Surround each name in the set
with braces, like \(dq{TAG_PROGRAM_AUTHOR}\(dq. You don\(aqt have to include the \(dq!_\(dq
pseudo tag prefix when specifying a name in the option argument for \fB\-\-pseudo\-tags=\fP
option.
.sp
pseudo\-tags don\(aqt have a notation using one\-letter flags.
.sp
If a name is preceded by either the \(aq+\(aq or \(aq\-\(aq characters, that
tags\(aqs effect has been added or removed. Otherwise the names replace
any current settings. All entries are included if \(aq*\(aq is given.
All entries are removed if nothing (\(aq\(aq) is given.
.TP
.B \fB\-\-fields=+E\fP (or \fB\-\-fields=+{extras}\fP)
Attach \(dqextras:pseudo\(dq field to pseudo\-tags.
.sp
An example of pseudo tags with the field:
.INDENT 7.0
.INDENT 3.5
.sp
.EX
!_TAG_PROGRAM_NAME      Universal Ctags /Derived from Exuberant Ctags/  extras:pseudo
.EE
.UNINDENT
.UNINDENT
.sp
If the name of a regular tag in a tag file starts with \(dq!_\(dq, a
client tool cannot distinguish whether the tag is a regular\-tag or
pseudo\-tag.  The fields attached with this option help the tool
distinguish them.
.UNINDENT
.SS List of notable pseudo\-tags
.sp
Running ctags with \fB\-\-list\-pseudo\-tags\fP option lists available types
of pseudo\-tags with short descriptions. This subsection shows hints
for using notable ones.
.INDENT 0.0
.TP
.B \fBTAG_EXTRA_DESCRIPTION\fP  (new in Universal Ctags)
Indicates the names and descriptions of enabled extras:
.INDENT 7.0
.INDENT 3.5
.sp
.EX
!_TAG_EXTRA_DESCRIPTION       {extra\-name}    /description/
!_TAG_EXTRA_DESCRIPTION!{language\-name}       {extra\-name}    /description/
.EE
.UNINDENT
.UNINDENT
.sp
If your tool relies on some extra tags (extras), refer to
the pseudo\-tags of this type. A tool can reject the tags file that
doesn\(aqt include expected extras, and raise an error in an early
stage of processing.
.sp
An example of the pseudo\-tags:
.INDENT 7.0
.INDENT 3.5
.sp
.EX
$ ctags \-\-extras=+p \-\-pseudo\-tags=\(aq{TAG_EXTRA_DESCRIPTION}\(aq \-o \- input.c
!_TAG_EXTRA_DESCRIPTION       anonymous       /Include tags for non\-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION       fileScope       /Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION       pseudo  /Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION       subparser       /Include tags generated by subparsers/
\&...
.EE
.UNINDENT
.UNINDENT
.sp
A client tool can know \(dq{anonymous}\(dq, \(dq{fileScope}\(dq, \(dq{pseudo}\(dq,
and \(dq{subparser}\(dq extras are enabled from the output.
.sp
Universal Ctags version 6.0 will turn on this pseudo tag by default.
.TP
.B \fBTAG_FIELD_DESCRIPTION\fP  (new in Universal Ctags)
Indicates the names and descriptions of enabled fields:
.INDENT 7.0
.INDENT 3.5
.sp
.EX
!_TAG_FIELD_DESCRIPTION       {field\-name}    /description/
!_TAG_FIELD_DESCRIPTION!{language\-name}       {field\-name}    /description/
.EE
.UNINDENT
.UNINDENT
.sp
If your tool relies on some fields, refer to the pseudo\-tags of
this type.  A tool can reject a tags file that doesn\(aqt include
expected fields, and raise an error in an early stage of
processing.
.sp
An example of the pseudo\-tags:
.INDENT 7.0
.INDENT 3.5
.sp
.EX
$ ctags \-\-fields\-C=+\(aq{macrodef}\(aq \-\-extras=+p \-\-pseudo\-tags=\(aq{TAG_FIELD_DESCRIPTION}\(aq \-o \- input.c
!_TAG_FIELD_DESCRIPTION       file    /File\-restricted scoping/
!_TAG_FIELD_DESCRIPTION       input   /input file/
!_TAG_FIELD_DESCRIPTION       name    /tag name/
!_TAG_FIELD_DESCRIPTION       pattern /pattern/
!_TAG_FIELD_DESCRIPTION       typeref /Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!C     macrodef        /macro definition/
\&...
.EE
.UNINDENT
.UNINDENT
.sp
A client tool can know \(dq{file}\(dq, \(dq{input}\(dq, \(dq{name}\(dq, \(dq{pattern}\(dq,
and \(dq{typeref}\(dq fields are enabled from the output.
The fields are common in languages. In addition to the common fields,
the tool can known \(dq{macrodef}\(dq field of C language is also enabled.
.sp
Universal Ctags version 6.0 will turn on this pseudo tag by default.
.TP
.B \fBTAG_FILE_ENCODING\fP  (new in Universal Ctags)
TBW
.TP
.B \fBTAG_FILE_FORMAT\fP
See also tags(5).
.TP
.B \fBTAG_FILE_SORTED\fP
See also tags(5).
.TP
.B \fBTAG_KIND_DESCRIPTION\fP (new in Universal Ctags)
Indicates the names and descriptions of enabled kinds:
.INDENT 7.0
.INDENT 3.5
.sp
.EX
!_TAG_KIND_DESCRIPTION!{language\-name}        {kind\-letter},{kind\-name}       /description/
.EE
.UNINDENT
.UNINDENT
.sp
If your tool relies on some kinds, refer to the pseudo\-tags of
this type.  A tool can reject the tags file that doesn\(aqt include
expected kinds, and raise an error in an early stage of
processing.
.sp
Kinds are language specific, so a language name is  always
appended to the tag name as suffix.
.sp
An example of the pseudo\-tags:
.INDENT 7.0
.INDENT 3.5
.sp
.EX
$ ctags \-\-extras=+p \-\-kinds\-C=vfm \-\-pseudo\-tags=\(aq{TAG_KIND_DESCRIPTION}\(aq \-o \- input.c
!_TAG_KIND_DESCRIPTION!C      f,function      /function definitions/
!_TAG_KIND_DESCRIPTION!C      m,member        /struct, and union members/
!_TAG_KIND_DESCRIPTION!C      v,variable      /variable definitions/
\&...
.EE
.UNINDENT
.UNINDENT
.sp
A client tool can know \(dq{function}\(dq, \(dq{member}\(dq, and \(dq{variable}\(dq
kinds of C language are enabled from the output.
.sp
Universal Ctags version 6.0 will turn on this pseudo tag by default.
.TP
.B \fBTAG_KIND_SEPARATOR\fP (new in Universal Ctags)
TBW
.TP
.B \fBTAG_OUTPUT_EXCMD\fP (new in Universal Ctags)
Indicates the specified type of EX command with \fB\-\-excmd\fP option.
.TP
.B \fBTAG_OUTPUT_FILESEP\fP (new in Universal Ctags)
Indicates filename separators (\(dqslash\(dq or \(dqbackslsh\(dq) used in input fields.
.sp
Universal Ctags running on MS Windows replaces backslashes with slashes
when emitting input fields by default. This pseudo tag is for
notifying this replacement to client tools.
.sp
See also the description for \fB\-\-use\-slash\-as\-filename\-separator\fP
option in ctags(1).
.TP
.B \fBTAG_OUTPUT_MODE\fP (new in Universal Ctags)
Indicates whether using Universal Ctags extended escape sequences (\(dqu\-ctags\(dq) or not (\(dqe\-ctags\(dq).
.sp
To reduce illegal characters like <Tab> in tags files, Universal
Ctags extends the escape sequences originally used in Exuberant
Ctags, and applies the escaping rules to more fields.
.sp
See tags(5) about the escaping rules.
.sp
\fB\-\-output\-format\fP option is for choosing the output mode within
the tags output format. See ctags(1) about the option.
.sp
In \(dqe\-ctags\(dq mode, for not violating the tags file format
described in tags(5), Universal Ctags skips emitting tag entries
including illegal characters like <Tab>.
.sp
In input fields ({tagfile} in tags(5)), we have one more
condition for applying the escaping rules: \fB\e\fP characters
are not used as filename separators. UNIX\-like systems use \fB/\fP
for the purpose. On MS Windows, Universal Ctags converts \fB\e\fP
in filenames to \fB/\fP by default. So, generally this condition is
satisfied. The condition is not satisfied only when you specify
\fB\-\-use\-slash\-as\-filename\-separator=no\fP on MS Windows.
.TP
.B \fBTAG_OUTPUT_VERSION\fP (new in Universal Ctags 6.0)
Indicates the language\-common interface version of the output:
.INDENT 7.0
.INDENT 3.5
.sp
.EX
!_TAG_OUTPUT_VERSION  {current}.{age} /.../
.EE
.UNINDENT
.UNINDENT
.sp
The public interface includes common fields, common extras,
pseudo tags.
.sp
The maintainer of Universal Ctags may update the numbers,
\(dq{current}\(dq and \(dq{age}\(dq in the same manner as explained
in \fBTAG_PARSER_VERSION\fP\&.
.TP
.B \fBTAG_PARSER_VERSION\fP (new in Universal Ctags 6.0)
Indicates the interface version of the parser:
.INDENT 7.0
.INDENT 3.5
.sp
.EX
!_TAG_PARSER_VERSION!{language\-name}  {current}.{age} /.../
.EE
.UNINDENT
.UNINDENT
.sp
The public interfaces include kinds, roles, language specific fields,
and language specific extras.
.sp
The maintainer of the parser for \(dq${language\-name}\(dq may update
the numbers, \(dq{current}\(dq and \(dq{age}\(dq in the following rules:
.INDENT 7.0
.IP \(bu 2
If kinds, roles, language specific fields, and/or language
specific extras have been added, removed or changed since last
release, increment \(dq{current}\(dq.
.IP \(bu 2
If they have been added since last release, increment \(dq{age}\(dq.
.IP \(bu 2
If they have been removed since last release, set \(dq{age}\(dq to 0.
.UNINDENT
.sp
This concept is based on the versioning in \fBlibtool\fP
(7.2 Libtool’s versioning system <https://www.gnu.org/software/libtool/manual/libtool.html#Libtool-versioning>
\&.)
In Universal Ctags, we simplified the concept with removing
\(dqrevision\(dq in the versioning in libtool.
.sp
Manual pages for languages may document changes that increase
the number of \(dq{current}\(dq.
.TP
.B \fBTAG_PATTERN_LENGTH_LIMIT\fP (new in Universal Ctags)
TBW
.TP
.B \fBTAG_PROC_CWD\fP (new in Universal Ctags)
Indicates the working directory of ctags during processing.
.sp
This pseudo\-tag helps a client tool solve the absolute paths for
the input files for tag entries even when they are tagged with
relative paths.
.sp
An example of the pseudo\-tags:
.INDENT 7.0
.INDENT 3.5
.sp
.EX
$ cat tags
!_TAG_PROC_CWD        /tmp/   //
main  input.c /^int main (void) { return 0; }$/;\(dq     f       typeref:typename:int
\&...
.EE
.UNINDENT
.UNINDENT
.sp
From the regular tag for \(dqmain\(dq, the client tool can know the
\(dqmain\(dq is at \(dqinput.c\(dq.  However, it is a relative path. So if the
directory where ctags run and the directory
where the client tool runs are different, the client tool cannot
find \(dqinput.c\(dq from the file system. In that case,
\fBTAG_PROC_CWD\fP gives the tool a hint; \(dqinput.c\(dq may be at \(dq/tmp\(dq.
.TP
.B \fBTAG_PROGRAM_NAME\fP
Indicates the name of program generating this tags file.
.TP
.B \fBTAG_PROGRAM_VERSION\fP
Indicates the version of program generating this tags file.
.TP
.B \fBTAG_ROLE_DESCRIPTION\fP (new in Universal Ctags)
Indicates the names and descriptions of enabled roles:
.INDENT 7.0
.INDENT 3.5
.sp
.EX
!_TAG_ROLE_DESCRIPTION!{language\-name}!{kind\-name}    {role\-name}     /description/
.EE
.UNINDENT
.UNINDENT
.sp
If your tool relies on some roles, refer to the pseudo\-tags of
this type. Note that a role owned by a disabled kind is not listed
even if the role itself is enabled.
.UNINDENT
.SH REDUNDANT-KINDS
.sp
TBW (Write about \-\-fields=+kKzZ)
.SH MULTIPLE-LANGUAGES FOR AN INPUT FILE
.sp
Universal ctags can run multiple parsers.
That means a parser, which supports multiple parsers (\fBguest parsers\fP or \fBsub\-parsers\fP), may output tags for
different languages.
.SS Guest parsers
.sp
A parser can run guest pursers on the areas in a source file.
.sp
Consider the following text as a source file (\(dqinput.html\(dq):
.INDENT 0.0
.INDENT 3.5
.sp
.EX
<html><head>
        <script>class MyObject {}</script>
        <style type=\(dqtext/css\(dq>h1.heading { color: red; }</style>
</htad>
<h1 class=\(aqheading\(aq>title</h1>
</html>
.EE
.UNINDENT
.UNINDENT
.sp
If a user doesn\(aqt specify any extras, Universal ctags emits:
.INDENT 0.0
.INDENT 3.5
.sp
.EX
$ ctags \-o \- input.html
title   input.html      /^<h1 class=\(aqheading\(aq>title<\e/h1>$/;\(dq   h
.EE
.UNINDENT
.UNINDENT
.sp
These is no issue here.
\fBrunning guest pursers\fP extra is disabled by default.
.sp
If a user enables the \fBrunning guest parsers\fP extra with specifying
\fB\-\-extras=+{guest}\fP or \fB\-\-extras=+g\fP, Universal ctags emits:
.INDENT 0.0
.INDENT 3.5
.sp
.EX
$ ctags \-o \- \-\-extras=\(aq{guest}\(aq input.html
MyObject        input.html      /class MyObject {}/;\(dq   c
h1.heading      input.html      /h1.heading { color: red; }/;\(dq  c
title   input.html      /^<h1 class=\(aqheading\(aq>title<\e/h1>$/;\(dq   h
.EE
.UNINDENT
.UNINDENT
.sp
Universal ctags extracts the language objects for CSS and JavaScript; the HTML
parser runs JavaScript parser on the area \(dq\fB<script>...</script>\fP\(dq area
and CSS parser on the area \(dq\fB<style ...> ...</style>\fP\(dq area.
.sp
If a client tool assumes that ctags runs one parser for an input file,
the tool may tell \(dqMyObject is a class of HTML\(dq and/or \(dqh1.heading is
a class of HTML\(dq to its users. \fBc\fP is too few information to
tell what is \(dqMyObject\(dq and what is \(dqh1.heading\(dq correctly. The
client tool needs more information.
.sp
\fBlanguage\fP/\fBl\fP field can be used to show the language
for each tag.
.INDENT 0.0
.INDENT 3.5
.sp
.EX
$ ctags \-o \- \-\-extras=\(aq{guest}\(aq \-\-fields=+\(aq{language}\(aq input.html
MyObject        input.html      /class MyObject {}/;\(dq   c       language:JavaScript
h1.heading      input.html      /h1.heading { color: red; }/;\(dq  c       language:CSS
title   input.html      /^<h1 class=\(aqheading\(aq>title<\e/h1>$/;\(dq   h       language:HTML
.EE
.UNINDENT
.UNINDENT
.sp
For some class tools, the \fBlanguage:\fP field provides enough information.
Universal ctags can emits more self\-descriptive tag file.
.sp
Enabling \fBK\fP field with \fB\-\-fields=+K\fP option, Universal ctags uses
long\-names instead of single\-letter to represent kind fields:
.INDENT 0.0
.INDENT 3.5
.sp
.EX
$ ctags \-o \- \-\-extras=\(aq{guest}\(aq \-\-fields=+\(aq{language}K\(aq input.html
MyObject        /tmp/input.html /class MyObject {}/;\(dq   class   language:JavaScript
h1.heading      /tmp/input.html /h1.heading { color: red; }/;\(dq  class   language:CSS
title   /tmp/input.html /^<h1 class=\(aqheading\(aq>title<\e/h1>$/;\(dq   heading1        language:HTML
.EE
.UNINDENT
.UNINDENT
.sp
The long\-name representation makes tag files larger.
If you want to keep a tag file small, you can make your tool utilize pseudo\-tags
instead of enabling \fBK\fP field. Universal ctags emits the following line at the
beginning of a tags file by default:
.INDENT 0.0
.INDENT 3.5
.sp
.EX
$ cat ./tags
\&...
!_TAG_KIND_DESCRIPTION!CSS      c,class /classes/
\&...
!_TAG_KIND_DESCRIPTION!HTML     c,class /classes/
!_TAG_KIND_DESCRIPTION!HTML     h,heading1      /H1 headings/
\&...
!_TAG_KIND_DESCRIPTION!JavaScript       c,class /classes/
\&...
.EE
.UNINDENT
.UNINDENT
.sp
From the second field of the output, a tool can know the mapping
between a single\-letter for a kind and a long\-name for the kind.
.sp
Universal ctags emits pseudo\-tags to tag files by default. However, if
you make ctags emit to standard output with \fB\-o \-\fP or \fB\-f \-\fP
option, ctags doesn\(aqt print pseudo\-tags.  \fBpseudo\fP/\fBp\fP extra
forces emitting.
.INDENT 0.0
.INDENT 3.5
.sp
.EX
$ ctags \-o \- \-\-extras=\(aq{guest}{pseudo}\(aq \-\-fields=+\(aq{language}\(aq input.html
\&...
!_TAG_KIND_DESCRIPTION!CSS      c,class /classes/
\&...
!_TAG_KIND_DESCRIPTION!HTML     c,class /classes/
!_TAG_KIND_DESCRIPTION!HTML     h,heading1      /H1 headings/
\&...
!_TAG_KIND_DESCRIPTION!JavaScript       c,class /classes/
\&...
.EE
.UNINDENT
.UNINDENT
.SS Sub\-parsers
.sp
TBW
.SH UTILIZING READTAGS
.sp
See readtags(1) to know how to use readtags. This section is for discussing
some notable topics for client tools.
.SS Build Filter/Sorter Expressions
.sp
Certain escape sequences in expressions are recognized by readtags. For
example, when searching for a tag that matches \fBa\e?b\fP, if using a filter
expression like \fB\(aq(eq? $name \(dqa\e?b\(dq)\(aq\fP, since \fB\e?\fP is translated into a
single \fB?\fP by readtags, it actually searches for \fBa?b\fP\&.
.sp
Another problem is: If the client tools talks to readtags not by subprocess
directly, but through a shell, then if a single quote appear in filter
expressions (which is also wrapped by single quotes), it terminates the
expression, producing broken expressions, and may even cause unintended shell
injection. Single quotes can be escaped using \fB\(aq\(dq\(aq\(dq\(aq\fP\&.
.sp
So, client tools need to:
.INDENT 0.0
.IP \(bu 2
Replace \fB\e\fP by \fB\e\e\fP
.IP \(bu 2
Replace \fB\(aq\fP by \fB\(aq\(dq\(aq\(dq\(aq\fP, if it talks to readtags through a shell.
.UNINDENT
.sp
inside the expressions. If the expression also contains strings, \fB\(dq\fP in the
strings needs to be replaced by \fB\e\(dq\fP\&.
.sp
Another thing to notice is that missing fields are represented by \fB#f\fP, and
applying string operators to them will produce an error. You should always
check if a field is missing before applying string operators. See the
\(dqFiltering\(dq section in readtags(1) to know how to do this. Run \(dqreadtags \-H
filter\(dq to see which operators take string arguments.
.SS Build Filter/Sorter Expressions using Lisp Languages
.sp
Client tools written in Lisp could build the expression using lists. \fBprin1\fP
(in Common Lisp style Lisps) and \fBwrite\fP (in Scheme style Lisps) can
translate the list into a string that can be directly used. For example, in
EmacsLisp:
.INDENT 0.0
.INDENT 3.5
.sp
.EX
(let ((name \(dqhi\(dq))
  (prin1 \(ga(eq? $name ,name)))
=> \(dq(eq\e\e? $name \(dqhi\(dq)\(dq
.EE
.UNINDENT
.UNINDENT
.sp
The \(dq?\(dq is escaped, and readtags can handle it.
.sp
Escape sequences produced by \fBwrite\fP in Scheme style Lisps are exactly those
supported by readtags, so any legal readtags expressions can be used. Common
Lisp style Lisps may produce escape sequences that are unrecgonized by
readtags, like \fB\e#\fP, so symbols that contain \(dq#\(dq can\(aqt be used. Readtags
provides some aliases for these Lisps, so they should:
.INDENT 0.0
.IP \(bu 2
Use \fBtrue\fP for \fB#t\fP\&.
.IP \(bu 2
Use \fBfalse\fP for \fB#f\fP\&.
.IP \(bu 2
Use \fBnil\fP or \fB()\fP for \fB()\fP\&.
.IP \(bu 2
Use \fB(string\->regexp \(dqPATTERN\(dq)\fP for \fB#/PATTERN/\fP\&. Use
\fB(string\->regexp \(dqPATTERN\(dq :case\-fold true)\fP for \fB#/PATTERN/i\fP\&. Notice
that \fBstring\->regexp\fP doesn\(aqt require escaping \(dq/\(dq in the pattern.
.UNINDENT
.sp
Notice that if the client tool talks to readtags through a shell, then in the
produced string, \fB\(aq\fP still needs to be replaced by \fB\(aq\(dq\(aq\(dq\(aq\fP to prevent
broken expressions and shell injection.
.SS Parse Readtags Output
.sp
In the output of readtags, tabs can appear in all field values (e.g., the tag
name itself could contain tabs), which makes it hard to split the line into
fields. Client tools should use the \fB\-E\fP option, which keeps the escape
sequences in the tags file, so the only field that could contain tabs is the
pattern field.
.sp
The pattern field could:
.INDENT 0.0
.IP \(bu 2
Use a line number. It will look like \fBnumber;\(dq\fP (e.g. \fB10;\(dq\fP).
.IP \(bu 2
Use a search pattern. It will look like \fB/pattern/;\(dq\fP or \fB?pattern?;\(dq\fP\&.
Notice that the search pattern could contain tabs.
.IP \(bu 2
Combine these two, like \fBnumber;/pattern/;\(dq\fP or \fBnumber;?pattern?;\(dq\fP\&.
.UNINDENT
.sp
These are true for tags files using extended format, which is the default one.
The legacy format (i.e. \fB\-\-format=1\fP) doesn\(aqt include the semicolons. It\(aqs
old and barely used, so we won\(aqt discuss it here.
.sp
Client tools could split the line using the following steps:
.INDENT 0.0
.IP \(bu 2
Find the first 2 tabs in the line, so we get the name and input field.
.IP \(bu 2
From the 2nd tab:
.INDENT 2.0
.IP \(bu 2
If a \fB/\fP follows, then the pattern delimiter is \fB/\fP\&.
.IP \(bu 2
If a \fB?\fP follows, then the pattern delimiter is \fB?\fP\&.
.IP \(bu 2
If a number follows, then:
.INDENT 2.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
If a \fB;/\fP follows the number, then the delimiter is \fB/\fP\&.
.IP \(bu 2
If a \fB;?\fP follows the number, then the delimiter is \fB?\fP\&.
.IP \(bu 2
If a \fB;\(dq\fP follows the number, then the field uses only line number, and
there\(aqs no pattern delimiter (since there\(aqs no regex pattern). In this
case the pattern field ends at the 3rd tab.
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.IP \(bu 2
After the opening delimiter, find the next unescaped pattern delimiter, and
that\(aqs the closing delimiter. It will be followed by \fB;\(dq\fP and then a tab.
That\(aqs the end of the pattern field. By \(dqunescaped pattern delimiter\(dq, we
mean there\(aqs an even number (including 0) of backslashes before it.
.IP \(bu 2
From here, split the rest of the line into fields by tabs.
.UNINDENT
.sp
Then, the escape sequences in fields other than the pattern field should be
translated. See \(dqProposal\(dq in tags(5) to know about all the escape sequences.
.SS Make Use of the Pattern Field
.sp
The pattern field specifies how to find a tag in its source file. The code
generating this field seems to have a long history, so there are some pitfalls
and it\(aqs a bit hard to handle. A client tool could simply require the \fBline:\fP
field and jump to the line it specifies, to avoid using the pattern field. But
anyway, we\(aqll discuss how to make the best use of it here.
.sp
You should take the words here merely as suggestions, and not standards. A
client tool could definitely develop better (or simpler) ways to use the
pattern field.
.sp
From the last section, we know the pattern field could contain a line number
and a search pattern. When it only contains the line number, handling it is
easy: you simply go to that line.
.sp
The search pattern resembles an EX command, but as we\(aqll see later, it\(aqs
actually not a valid one, so some manual work are required to process it.
.sp
The search pattern could look like \fB/pat/\fP, called \(dqforward search pattern\(dq,
or \fB?pat?\fP, called \(dqbackward search pattern\(dq. Using a search pattern means
even if the source file is updated, as long as the part containing the tag
doesn\(aqt change, we could still locate the tag correctly by searching.
.sp
When the pattern field only contains the search pattern, you just search for
it. The search direction (forward/backward) doesn\(aqt matter, as it\(aqs decided
solely by whether the \fB\-B\fP option is enabled, and not the actual context. You
could always start the search from say the beginning of the file.
.sp
When both the search pattern and the line number are presented, you could make
good use of the line number, by going to the line first, then searching for the
nearest occurrence of the pattern. A way to do this is to search both forward
and backward for the pattern, and when there is a occurrence on both sides, go
to the nearer one.
.sp
What\(aqs good about this is when there are multiple identical lines in the source
file (e.g. the COMMON block in Fortran), this could help us find the correct
one, even after the source file is updated and the tag position is shifted by a
few lines.
.sp
Now let\(aqs discuss how to search for the pattern. After you trim the \fB/\fP or
\fB?\fP around it, the pattern resembles a regex pattern. It should be a regex
pattern, as required by being a valid EX command, but it\(aqs actually not, as
you\(aqll see below.
.sp
It could begin with a \fB^\fP, which means the pattern starts from the beginning
of a line. It could also end with an \fIunescaped\fP \fB$\fP which means the pattern
ends at the end of a line. Let\(aqs keep this information, and trim them too.
.sp
Now the remaining part is the actual string containing the tag. Some characters
are escaped:
.INDENT 0.0
.IP \(bu 2
\fB\e\fP\&.
.IP \(bu 2
\fB$\fP, but only at the end of the string.
.IP \(bu 2
\fB/\fP, but only in forward search patterns.
.IP \(bu 2
\fB?\fP, but only in backward search patterns.
.UNINDENT
.sp
You need to unescape these to get the literal string. Now you could convert
this literal string to a regexp that matches it (by escaping, like
\fBre.escape\fP in Python or \fBregexp\-quote\fP in Elisp), and assemble it with
\fB^\fP or \fB$\fP if the pattern originally has it, and finally search for the tag
using this regexp.
.SS Remark: About a Previous Format of the Pattern Field
.sp
In some earlier versions of Universal Ctags, the line number in the pattern
field is the actual line number minus one, for forward search patterns; or plus
one, for backward search patterns. The idea is to resemble an EX command: you
go to the line, then search forward/backward for the pattern, and you can
always find the correct one. But this denies the purpose of using a search
pattern: to tolerate file updates. For example, the tag is at line 50,
according to this scheme, the pattern field should be:
.INDENT 0.0
.INDENT 3.5
.sp
.EX
49;/pat/;\(dq
.EE
.UNINDENT
.UNINDENT
.sp
Then let\(aqs assume that some code above are removed, and the tag is now at
line 45. Now you can\(aqt find it if you search forward from line 49.
.sp
Due to this reason, Universal Ctags turns to use the actual line number. A
client tool could distinguish them by the \fBTAG_OUTPUT_EXCMD\fP pseudo tag, it\(aqs
\(dqcombine\(dq for the old scheme, and \(dqcombineV2\(dq for the present scheme. But
probably there\(aqs no need to treat them differently, since \(dqsearch for the
nearest occurrence from the line\(dq gives good result on both schemes.
.SH JSON OUTPUT
.sp
See ctags\-json\-output(5).
.SH CHANGES
.SS Version 6.0
.INDENT 0.0
.IP \(bu 2
ctags enables \fBTAG_KIND_DESCRIPTION\fP, \fBTAG_ROLE_DESCRIPTION\fP,
\fBTAG_FIELD_DESCRIPTION\fP, and \fBTAG_EXTRA_DESCRIPTION\fP pseudo tags by default.
.IP \(bu 2
\fBTAG_PARSER_VERSION\fP is introduced.
.UNINDENT
.SH SEE ALSO
.sp
ctags(1), ctags\-lang\-python(7), ctags\-incompatibilities(7), tags(5), ctags\-json\-output(5), readtags(1),
\fI7.2 Libtool’s versioning system <https://www.gnu.org/software/libtool/manual/libtool.html#Libtool\-versioning>\fP
.\" Generated by docutils manpage writer.
.
